#!/bin/sh

# TODO:
# - roll back after errors or SIGINT
#   - current checkout
#   - created revs
#   - main (for git arc stage)

err()
{
    echo "$(basename $0): $1" >&2
    exit 1
}

err_usage()
{
    cat >&2 <<__EOF__
Usage: git arc <command> <arguments>

Commands:
  create [-r <reviewer1>[,<reviewer2>...]] [-s subscriber[,...]] [<commit>|<commit range>]
  patch <diff1> [<diff2> ...]
  stage [<commit>|<commit range>]
  update <commit>

Description:
  Create or update a FreeBSD Phabricator review, or apply a patch from an
  existing review to a local git checkout.  There is a one-to-one relationship
  between git commits and Differential revisions, and the Differential review
  title must match the summary line of the corresponding commit.  If the review
  is created using this script, that will happen automatically.

Config Variables:
  arc.browse [bool] -- Try to open newly created reviews in a browser tab.
                       Defaults to false.

Examples:

  Create a Phabricator review using the contents of the most recent commit in
  your git checkout.  The commit title is used as the review title, the commit
  log message is used as the review description, markj@FreeBSD.org is added as
  a reviewer.

  $ git arc create -r markj HEAD

  Create a series of Phabricator reviews for each of HEAD~2, HEAD~ and HEAD.
  Pairs of consecutive commits are linked into a patch stack.  Note that the
  first commit in the specified range is excluded.

  $ git arc create HEAD~3..HEAD

  Update the review corresponding to commit b409afcfedcdda.  The title of the
  commit must be the same as it was when the review was created.  The review
  description is not automatically updated.

  $ git arc update b409afcfedcdda

  Apply the patch in review D12345 to the currently checked-out tree, and stage
  it.

  $ git arc patch D12345
__EOF__

    exit 1
}

diff2phid()
{
    local diff

    diff=$1
    if ! expr "$diff" : 'D[1-9][0-9]*$' >/dev/null; then
        err "invalid diff ID $diff"
    fi

    echo '{"names":["'$diff'"]}' |
        arc call-conduit -- phid.lookup |
        jq -r "select(.response != []) | .response.${diff}.phid"
}

commit2diff()
{
    local commit diff title

    commit=$1
    title=$(git show -s --format=%s $commit)
    diff=$(arc list | fgrep "$title" | egrep -o 'D[1-9][0-9]*:' | tr -d ':')
    if [ -z "$diff" ]; then
        err "could not find review for '${title}'"
    elif [ $(echo "$diff" | wc -l) -ne 1 ]; then
        err "found multiple reviews with the same title"
    fi

    echo $diff
}

create_one_review()
{
    local childphid commit dir msg parent parentphid reviewers subscribers

    commit=$1
    reviewers=$2
    subscribers=$3
    parent=$4

    if ! show_and_prompt $commit; then
        return
    fi

    git checkout -q $commit

    dir=$(git rev-parse --git-dir)/arc
    mkdir -p "$dir"

    msg=${dir}/create-message
    git show -s --format='%B' $commit > $msg
    printf "\nTest Plan:\n" >> $msg
    printf "\nReviewers:\n" >> $msg
    printf "${reviewers}\n" >> $msg
    printf "\nSubscribers:\n" >> $msg
    printf "${subscribers}\n" >> $msg

    yes | env EDITOR=true \
        arc diff --never-apply-patches --create --allow-untracked $BROWSE HEAD~
    [ $? -eq 0 ] || err "could not create Phabricator diff"

    if [ -n "$parent" ]; then
        diff=$(commit2diff $commit)
        [ -n "$diff" ] || err "failed to look up review ID for $commit"

        childphid=$(diff2phid $diff)
        parentphid=$(diff2phid $parent)
        echo '{
            "objectIdentifier": "'${childphid}'",
            "transactions": [
                {
                    "type": "parents.add",
                    "value": ["'${parentphid}'"]
                }
             ]}' |
            arc call-conduit -- differential.revision.edit
    fi
}

# Get a list of reviewers who accepted the specified diff.
diff2reviewers()
{
    local diff phid reviewid userids

    diff=$1
    reviewid=$(diff2phid $diff)
    userids=$( \
        echo '{
                  "constraints": {"phids": ["'$reviewid'"]},
                  "attachments": {"reviewers": true}
              }' |
        arc call-conduit -- differential.revision.search |
        jq '.response.data[0].attachments.reviewers.reviewers[] | select(.status == "accepted").reviewerPHID')
    if [ -n "$userids" ]; then
        echo '{
                  "constraints": {"phids": ['$(echo -n $userids | tr '[:space:]' ',')']}
              }' |
            arc call-conduit -- user.search |
            jq -r '.response.data[].fields.username'
    fi
}

show_and_prompt()
{
    local commit

    commit=$1

    git show $commit
    printf "\nDoes this look OK? [y/N] "
    read resp

    case $resp in
    [Yy])
        return 0
        ;;
    *)
        return 1
        ;;
    esac
}

save_head()
{
    local commit orig

    if ! orig=$(git symbolic-ref --short -q HEAD); then
        orig=$(git show -s --pretty=%H HEAD)
    fi
    echo $orig
}

restore_head()
{
    local orig

    orig=$1
    git checkout -q $orig
}

gitarc::create()
{
    local commit commits orig prev reviewers subscribers

    while getopts r:s: o; do
        case "$o" in
        r)
            reviewers="$OPTARG"
            ;;
        s)
            subscribers="$OPTARG"
            ;;
        *)
            err_usage
            ;;
        esac
        shift $((OPTIND-1))
    done

    orig=$(save_head)
    prev=""
    for chash in $@; do
        # Convert each commit or commit range into a list of hashes.
        commits=$(git rev-parse "${chash}")
        if ! git cat-file -e "${chash}"'^{commit}' >/dev/null 2>&1; then
            commits=$(git rev-list $commits | tail -r)
            [ -n "$commits" ] || err "invalid commit ID ${chash}"
        fi
        for commit in ${commits}; do
            create_one_review "$commit" "$reviewers" "$subscribers" "$prev"
            prev=$(commit2diff "$commit")
        done
    done
    restore_head $orig
}

gitarc::patch()
{
    local rev

    if [ $# -eq 0 ]; then
        err_usage
    fi

    for rev in $@; do
        arc patch --skip-dependencies --nocommit --nobranch --force $rev
        echo "Applying ${rev}..."
        [ $? -eq 0 ] || break
    done
}

gitarc::stage()
{
    local _commits commit commits diff orig reviewers tmp

    # Convert each commit or commit range into a list of hashes.
    for chash in $@; do
        _commits=$(git rev-parse "${chash}")
        if ! git cat-file -e "${chash}"'^{commit}' >/dev/null 2>&1; then
            _commits=$(git rev-list $_commits | tail -r)
        fi
        [ -n "$_commits" ] || err "invalid commit ID ${chash}"
        commits="$commits $_commits"
    done

    orig=$(save_head)

    git checkout -q main

    tmp=$(mktemp)
    for commit in $commits; do
        git show -s --format=%B $commit > $tmp
        diff=$(arc list | fgrep "$(git show -s --format=%s $commit)" |
            egrep -o 'D[1-9][0-9]*:' | tr -d ':')
        if [ -n "$diff" ]; then
            reviewers=$(diff2reviewers $diff | sed '/^$/d' | paste -sd ',' - | sed 's/,/, /g')
            if [ -n "$reviewers" ]; then
                printf "Reviewed by:\t${reviewers}\n" >> $tmp
            fi
            printf "Differential Revision:\thttps://reviews.freebsd.org/${diff}" >> $tmp
        fi
        git cherry-pick --no-commit $commit
        git commit --edit --file $tmp
    done

    restore_head $orig
}

gitarc::update()
{
    local commit diff orig

    commit=$1
    diff=$(commit2diff $commit)

    if ! show_and_prompt $commit; then
        return
    fi

    orig=$(save_head)
    git checkout -q $commit

    # The linter is stupid and applies patches to the working copy.
    # This would be tolerable if it didn't try to correct "misspelled" variable
    # names.
    arc diff --never-apply-patches --update $diff HEAD~

    restore_head $orig
}

set -e

[ $# -ge 1 ] || err_usage

case "$1" in
create|patch|stage|update)
    ;;
*)
    err_usage
    ;;
esac
verb=$1
shift

# Pull in some git helper functions.
git_sh_setup=$(git --exec-path)/git-sh-setup
[ -f "$git_sh_setup" ] || err "cannot find git-sh-setup"
SUBDIRECTORY_OK=y
USAGE=
. "$git_sh_setup"

# Bail if the working tree is unclean, except for "patch" operations.
case $verb in
patch)
    ;;
*)
    require_clean_work_tree $verb
    ;;
esac

if eval $(git config --bool --default false --get arc.browse); then
    BROWSE=--browse
fi

gitarc::${verb} $@
